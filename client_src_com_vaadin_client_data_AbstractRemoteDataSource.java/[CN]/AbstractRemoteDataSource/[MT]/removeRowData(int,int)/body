{
  Profiler.enter("AbstractRemoteDataSource.removeRowData");
  for (int i=0; i < count; i++) {
    Integer oldIndex=Integer.valueOf(firstRowIndex + count + i);
    if (rowCache.containsKey(oldIndex)) {
      Integer newIndex=Integer.valueOf(firstRowIndex + i);
      rowCache.put(newIndex,rowCache.remove(oldIndex));
    }
  }
  Range removedRange=Range.withLength(firstRowIndex,count);
  if (cached.isSubsetOf(removedRange)) {
    cached=Range.withLength(0,0);
  }
 else   if (removedRange.intersects(cached)) {
    Range[] partitions=cached.partitionWith(removedRange);
    Range remainsBefore=partitions[0];
    Range transposedRemainsAfter=partitions[2].offsetBy(-removedRange.length());
    cached=remainsBefore.combineWith(transposedRemainsAfter);
  }
  dataChangeHandler.dataRemoved(firstRowIndex,count);
  checkCacheCoverage();
  Profiler.leave("AbstractRemoteDataSource.removeRowData");
}
