{
  this.client=client;
  final Collection<Widget> oldWidgets=new HashSet<Widget>();
  for (final Iterator<Widget> iterator=iterator(); iterator.hasNext(); ) {
    oldWidgets.add(iterator.next());
  }
  ValueMap mapAttribute=null;
  if (uidl.hasAttribute("css")) {
    mapAttribute=uidl.getMapAttribute("css");
  }
  lastIndex=0;
  for (final Iterator<Object> i=uidl.getChildIterator(); i.hasNext(); ) {
    final UIDL r=(UIDL)i.next();
    final VPaintableWidget child=client.getPaintable(r);
    final Widget widget=child.getWidgetForPaintable();
    if (widget.getParent() == this) {
      oldWidgets.remove(widget);
      VCaption vCaption=widgetToCaption.get(widget);
      if (vCaption != null) {
        addOrMove(vCaption,lastIndex++);
        oldWidgets.remove(vCaption);
      }
    }
    addOrMove(widget,lastIndex++);
    if (mapAttribute != null && mapAttribute.containsKey(r.getId())) {
      String css=null;
      try {
        Style style=widget.getElement().getStyle();
        css=mapAttribute.getString(r.getId());
        String[] cssRules=css.split(";");
        for (int j=0; j < cssRules.length; j++) {
          String[] rule=cssRules[j].split(":");
          if (rule.length == 0) {
            continue;
          }
 else {
            style.setProperty(makeCamelCase(rule[0].trim()),rule[1].trim());
          }
        }
      }
 catch (      Exception e) {
        VConsole.log("CssLayout encounterd invalid css string: " + css);
      }
    }
    if (!r.getBooleanAttribute("cached")) {
      child.updateFromUIDL(r,client);
    }
  }
  for (  Widget w : oldWidgets) {
    remove(w);
    VPaintableMap paintableMap=VPaintableMap.get(client);
    if (paintableMap.isPaintable(w)) {
      final VPaintableWidget p=VPaintableMap.get(client).getPaintable(w);
      client.unregisterPaintable(p);
    }
    VCaption vCaption=widgetToCaption.remove(w);
    if (vCaption != null) {
      remove(vCaption);
    }
  }
}
