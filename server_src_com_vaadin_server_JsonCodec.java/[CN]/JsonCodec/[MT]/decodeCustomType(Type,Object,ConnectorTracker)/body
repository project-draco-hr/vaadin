{
  if (isInternalType(targetType)) {
    throw new JSONException("decodeCustomType cannot be used for " + targetType + ", which is an internal type");
  }
  if (value == JSONObject.NULL) {
    return null;
  }
 else   if (targetType == byte.class || targetType == Byte.class) {
    return Byte.valueOf(String.valueOf(value));
  }
 else   if (targetType == char.class || targetType == Character.class) {
    return Character.valueOf(String.valueOf(value).charAt(0));
  }
 else   if (targetType instanceof Class<?> && ((Class<?>)targetType).isArray()) {
    Class<?> componentType=((Class<?>)targetType).getComponentType();
    return decodeArray(componentType,(JSONArray)value,connectorTracker);
  }
 else   if (targetType instanceof GenericArrayType) {
    Type componentType=((GenericArrayType)targetType).getGenericComponentType();
    return decodeArray(componentType,(JSONArray)value,connectorTracker);
  }
 else   if (targetType == JSONObject.class || targetType == JSONArray.class) {
    return value;
  }
 else   if (Enum.class.isAssignableFrom(getClassForType(targetType))) {
    Class<?> classForType=getClassForType(targetType);
    return decodeEnum(classForType.asSubclass(Enum.class),(String)value);
  }
 else   if (customSerializers.containsKey(getClassForType(targetType))) {
    return customSerializers.get(getClassForType(targetType)).deserialize(targetType,value,connectorTracker);
  }
 else {
    return decodeObject(targetType,(JSONObject)value,connectorTracker);
  }
}
