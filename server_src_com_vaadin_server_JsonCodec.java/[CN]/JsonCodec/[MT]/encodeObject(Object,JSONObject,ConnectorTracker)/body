{
  JSONObject encoded=new JSONObject();
  JSONObject diff=new JSONObject();
  try {
    for (    BeanProperty property : getProperties(value.getClass())) {
      String fieldName=property.getName();
      Type fieldType=property.getType();
      Object fieldValue=property.getValue(value);
      if (encoded.has(fieldName)) {
        throw new RuntimeException("Can't encode " + value.getClass().getName() + " as it has multiple properties with the name "+ fieldName.toLowerCase()+ ". This can happen if there are getters and setters for a public field (the framework can't know which to ignore) or if there are properties with only casing distinguishing between the names (e.g. getFoo() and getFOO())");
      }
      Object fieldReference;
      if (referenceValue != null) {
        fieldReference=referenceValue.get(fieldName);
        if (JSONObject.NULL.equals(fieldReference)) {
          fieldReference=null;
        }
      }
 else {
        fieldReference=null;
      }
      EncodeResult encodeResult=encode(fieldValue,fieldReference,fieldType,connectorTracker);
      encoded.put(fieldName,encodeResult.getEncodedValue());
      if (!jsonEquals(encodeResult.getEncodedValue(),fieldReference)) {
        diff.put(fieldName,encodeResult.getDiffOrValue());
      }
    }
  }
 catch (  Exception e) {
    throw new JSONException(e);
  }
  return new EncodeResult(encoded,diff);
}
