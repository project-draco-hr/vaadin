{
  boundary=CRLF + "--" + boundary+ "--";
  final InputStream inputStream=request.getInputStream();
  int contentLength=request.getContentLength();
  boolean atStart=false;
  String rawfilename="unknown";
  String rawMimeType="application/octet-stream";
  while (!atStart) {
    String readLine=readLine(inputStream);
    contentLength-=(readLine.length() + 2);
    if (readLine.startsWith("Content-Disposition:") && readLine.indexOf("filename=") > 0) {
      rawfilename=readLine.replaceAll(".*filename=","");
      String parenthesis=rawfilename.substring(0,1);
      rawfilename=rawfilename.substring(1);
      rawfilename=rawfilename.substring(0,rawfilename.indexOf(parenthesis));
    }
 else     if (readLine.equals("")) {
      atStart=true;
    }
 else     if (readLine.startsWith("Content-Type")) {
      rawMimeType=readLine.split(": ")[1];
    }
  }
  contentLength-=(boundary.length() + 2);
  final char[] charArray=boundary.toCharArray();
  InputStream simpleMultiPartReader=new InputStream(){
    /** 
 * Counter of how many characters have been matched to boundary
 * string from the stream
 */
    int matchedCount=0;
    /** 
 * Used as pointer when returning bytes after partly matched
 * boundary string.
 */
    int curBoundaryIndex=0;
    /** 
 * The byte found after a "promising start for boundary"
 */
    private int bufferedByte=-1;
    private boolean atTheEnd=false;
    @Override public int read() throws IOException {
      if (atTheEnd) {
        return -1;
      }
 else       if (bufferedByte >= 0) {
        return getBuffered();
      }
 else {
        int fromActualStream=inputStream.read();
        if (fromActualStream == -1) {
          throw new IOException("The multipart stream ended unexpectedly");
        }
        if (charArray[matchedCount] == fromActualStream) {
          while (true) {
            matchedCount++;
            if (matchedCount == charArray.length) {
              atTheEnd=true;
              return -1;
            }
            fromActualStream=inputStream.read();
            if (fromActualStream != charArray[matchedCount]) {
              bufferedByte=fromActualStream;
              return getBuffered();
            }
          }
        }
        return fromActualStream;
      }
    }
    private int getBuffered() throws IOException {
      int b;
      if (matchedCount == 0) {
        b=bufferedByte;
        bufferedByte=-1;
      }
 else {
        b=charArray[curBoundaryIndex++];
        if (curBoundaryIndex == matchedCount) {
          matchedCount=0;
          curBoundaryIndex=0;
        }
      }
      if (b == -1) {
        throw new IOException("The multipart stream ended unexpectedly");
      }
      return b;
    }
  }
;
  final String filename=removePath(rawfilename);
  final String mimeType=rawMimeType;
  try {
    Component component=(Component)owner;
    if (component.isReadOnly()) {
      throw new UploadException("Warning: file upload ignored because the componente was read-only");
    }
    streamToReceiver(simpleMultiPartReader,receiver,owner,filename,mimeType,contentLength);
  }
 catch (  Exception e) {
synchronized (application) {
      handleChangeVariablesError(application,(Component)owner,e,new HashMap<String,Object>());
    }
  }
  sendUploadResponse(request,response);
}
