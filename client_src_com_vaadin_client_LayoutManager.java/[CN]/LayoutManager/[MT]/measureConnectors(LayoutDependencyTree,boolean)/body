{
  if (!pendingOverflowFixes.isEmpty()) {
    Duration duration=new Duration();
    HashMap<Element,String> originalOverflows=new HashMap<Element,String>();
    HashSet<ComponentConnector> delayedOverflowFixes=new HashSet<ComponentConnector>();
    for (    ComponentConnector componentConnector : pendingOverflowFixes) {
      boolean connectorChangesExpected=!currentDependencyTree.noMoreChangesExpected(componentConnector);
      boolean parentChangesExcpected=componentConnector.getParent() instanceof ComponentConnector && !currentDependencyTree.noMoreChangesExpected((ComponentConnector)componentConnector.getParent());
      if (connectorChangesExpected || parentChangesExcpected) {
        delayedOverflowFixes.add(componentConnector);
        continue;
      }
      if (debugLogging) {
        VConsole.log("Doing overflow fix for " + Util.getConnectorString(componentConnector) + " in "+ Util.getConnectorString(componentConnector.getParent()));
      }
      Element parentElement=componentConnector.getWidget().getElement().getParentElement();
      Style style=parentElement.getStyle();
      String originalOverflow=style.getOverflow();
      if (originalOverflow != null && !originalOverflows.containsKey(parentElement)) {
        originalOverflows.put(parentElement,originalOverflow);
      }
      style.setOverflow(Overflow.HIDDEN);
    }
    pendingOverflowFixes.removeAll(delayedOverflowFixes);
    for (    ComponentConnector componentConnector : pendingOverflowFixes) {
      componentConnector.getWidget().getElement().getParentElement().getOffsetHeight();
    }
    for (    ComponentConnector componentConnector : pendingOverflowFixes) {
      Element parentElement=componentConnector.getWidget().getElement().getParentElement();
      parentElement.getStyle().setProperty("overflow",originalOverflows.get(parentElement));
      layoutDependencyTree.setNeedsMeasure(componentConnector,true);
    }
    if (!pendingOverflowFixes.isEmpty()) {
      VConsole.log("Did overflow fix for " + pendingOverflowFixes.size() + " elements  in "+ duration.elapsedMillis()+ " ms");
    }
    pendingOverflowFixes=delayedOverflowFixes;
  }
  int measureCount=0;
  if (measureAll) {
    ComponentConnector[] allConnectors=ConnectorMap.get(connection).getComponentConnectors();
    ArrayList<ComponentConnector> connectors=new ArrayList<ComponentConnector>();
    for (    ComponentConnector candidate : allConnectors) {
      if (needsMeasure(candidate.getWidget().getElement())) {
        connectors.add(candidate);
      }
    }
    for (    ComponentConnector connector : connectors) {
      measureConnector(connector);
    }
    for (    ComponentConnector connector : connectors) {
      layoutDependencyTree.setNeedsMeasure(connector,false);
    }
    measureCount+=connectors.size();
  }
  while (layoutDependencyTree.hasConnectorsToMeasure()) {
    Collection<ComponentConnector> measureTargets=layoutDependencyTree.getMeasureTargets();
    for (    ComponentConnector connector : measureTargets) {
      measureConnector(connector);
      measureCount++;
    }
    for (    ComponentConnector connector : measureTargets) {
      layoutDependencyTree.setNeedsMeasure(connector,false);
    }
  }
  return measureCount;
}
