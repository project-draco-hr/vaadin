{
  rendering=true;
  this.client=client;
  if (client.updateComponent(this,uidl,true)) {
    rendering=false;
    return;
  }
  boolean mightToggleVScrollBar="".equals(height) && !"".equals(width);
  boolean mightToggleHScrollBar="".equals(width) && !"".equals(height);
  int wBeforeRender=0;
  int hBeforeRender=0;
  if (mightToggleHScrollBar || mightToggleVScrollBar) {
    wBeforeRender=canvas.getOffsetWidth();
    hBeforeRender=getOffsetHeight();
  }
  canvas.setWidth("0px");
  handleMargins(uidl);
  detectSpacing(uidl);
  int cols=uidl.getIntAttribute("w");
  int rows=uidl.getIntAttribute("h");
  columnWidths=new int[cols];
  rowHeights=new int[rows];
  if (cells == null) {
    cells=new Cell[cols][rows];
  }
 else   if (cells.length != cols || cells[0].length != rows) {
    Cell[][] newCells=new Cell[cols][rows];
    for (int i=0; i < cells.length; i++) {
      for (int j=0; j < cells[i].length; j++) {
        if (i < cols && j < rows) {
          newCells[i][j]=cells[i][j];
        }
      }
    }
    cells=newCells;
  }
  nonRenderedWidgets=(HashMap<Widget,ChildComponentContainer>)widgetToComponentContainer.clone();
  final int[] alignments=uidl.getIntArrayAttribute("alignments");
  int alignmentIndex=0;
  LinkedList<Cell> pendingCells=new LinkedList<Cell>();
  LinkedList<Cell> relativeHeighted=new LinkedList<Cell>();
  for (final Iterator i=uidl.getChildIterator(); i.hasNext(); ) {
    final UIDL r=(UIDL)i.next();
    if ("gr".equals(r.getTag())) {
      for (final Iterator j=r.getChildIterator(); j.hasNext(); ) {
        final UIDL c=(UIDL)j.next();
        if ("gc".equals(c.getTag())) {
          Cell cell=getCell(c);
          if (cell.hasContent()) {
            boolean rendered=cell.renderIfNoRelativeWidth();
            cell.alignment=alignments[alignmentIndex++];
            if (!rendered) {
              pendingCells.add(cell);
            }
            if (cell.colspan > 1) {
              storeColSpannedCell(cell);
            }
 else             if (rendered) {
              if (columnWidths[cell.col] < cell.getWidth()) {
                columnWidths[cell.col]=cell.getWidth();
              }
            }
            if (cell.hasRelativeHeight()) {
              relativeHeighted.add(cell);
            }
          }
        }
      }
    }
  }
  distributeColSpanWidths();
  colExpandRatioArray=uidl.getIntArrayAttribute("colExpand");
  rowExpandRatioArray=uidl.getIntArrayAttribute("rowExpand");
  minColumnWidths=cloneArray(columnWidths);
  expandColumns();
  renderRemainingComponentsWithNoRelativeHeight(pendingCells);
  detectRowHeights();
  expandRows();
  renderRemainingComponents(pendingCells);
  for (  Cell cell : relativeHeighted) {
    Widget widget2=cell.cc.getWidget();
    client.handleComponentRelativeSize(widget2);
  }
  layoutCells();
  for (  Widget w : nonRenderedWidgets.keySet()) {
    ChildComponentContainer childComponentContainer=widgetToComponentContainer.get(w);
    paintableToCell.remove(w);
    widgetToComponentContainer.remove(w);
    childComponentContainer.removeFromParent();
    client.unregisterPaintable((Paintable)w);
  }
  nonRenderedWidgets=null;
  rendering=false;
  boolean needsRelativeSizeCheck=false;
  if (mightToggleHScrollBar && wBeforeRender != canvas.getOffsetWidth()) {
    needsRelativeSizeCheck=true;
  }
  if (mightToggleVScrollBar && hBeforeRender != getOffsetHeight()) {
    needsRelativeSizeCheck=true;
  }
  if (needsRelativeSizeCheck) {
    client.handleComponentRelativeSize(this);
  }
}
