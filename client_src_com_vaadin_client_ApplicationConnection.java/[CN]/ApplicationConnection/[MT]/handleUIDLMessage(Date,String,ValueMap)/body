{
  if (!responseHandlingLocks.isEmpty()) {
    VConsole.log("Postponing UIDL handling due to lock...");
    pendingUIDLMessages.add(new PendingUIDLMessage(start,jsonText,json));
    forceHandleMessage.schedule(MAX_SUSPENDED_TIMEOUT);
    return;
  }
  VConsole.log("Handling message from server");
  eventBus.fireEvent(new ResponseHandlingStartedEvent(this));
  if (json.containsKey("redirect")) {
    String url=json.getValueMap("redirect").getString("url");
    VConsole.log("redirecting to " + url);
    redirect(url);
    return;
  }
  lastResponseId++;
  final MultiStepDuration handleUIDLDuration=new MultiStepDuration();
  if (json.containsKey(ApplicationConstants.UIDL_SECURITY_TOKEN_ID)) {
    uidlSecurityKey=json.getString(ApplicationConstants.UIDL_SECURITY_TOKEN_ID);
  }
  VConsole.log(" * Handling resources from server");
  if (json.containsKey("resources")) {
    ValueMap resources=json.getValueMap("resources");
    JsArrayString keyArray=resources.getKeyArray();
    int l=keyArray.length();
    for (int i=0; i < l; i++) {
      String key=keyArray.get(i);
      resourcesMap.put(key,resources.getAsString(key));
    }
  }
  handleUIDLDuration.logDuration(" * Handling resources from server completed",10);
  VConsole.log(" * Handling type inheritance map from server");
  if (json.containsKey("typeInheritanceMap")) {
    configuration.addComponentInheritanceInfo(json.getValueMap("typeInheritanceMap"));
  }
  handleUIDLDuration.logDuration(" * Handling type inheritance map from server completed",10);
  VConsole.log("Handling type mappings from server");
  if (json.containsKey("typeMappings")) {
    configuration.addComponentMappings(json.getValueMap("typeMappings"),widgetSet);
  }
  VConsole.log("Handling resource dependencies");
  if (json.containsKey("scriptDependencies")) {
    loadScriptDependencies(json.getJSStringArray("scriptDependencies"));
  }
  if (json.containsKey("styleDependencies")) {
    loadStyleDependencies(json.getJSStringArray("styleDependencies"));
  }
  handleUIDLDuration.logDuration(" * Handling type mappings from server completed",10);
  if (json.containsKey("timings")) {
    serverTimingInfo=json.getValueMap("timings");
  }
  Command c=new Command(){
    @Override public void execute(){
      handleUIDLDuration.logDuration(" * Loading widgets completed",10);
      Profiler.enter("Handling locales");
      if (json.containsKey("locales")) {
        VConsole.log(" * Handling locales");
        JsArray<ValueMap> valueMapArray=json.getJSValueMapArray("locales");
        LocaleService.addLocales(valueMapArray);
      }
      Profiler.leave("Handling locales");
      Profiler.enter("Handling meta information");
      ValueMap meta=null;
      if (json.containsKey("meta")) {
        VConsole.log(" * Handling meta information");
        meta=json.getValueMap("meta");
        if (meta.containsKey("repaintAll")) {
          prepareRepaintAll();
          if (meta.containsKey("invalidLayouts")) {
            validatingLayouts=true;
          }
        }
        if (meta.containsKey("timedRedirect")) {
          final ValueMap timedRedirect=meta.getValueMap("timedRedirect");
          redirectTimer=new Timer(){
            @Override public void run(){
              redirect(timedRedirect.getString("url"));
            }
          }
;
          sessionExpirationInterval=timedRedirect.getInt("interval");
        }
      }
      Profiler.leave("Handling meta information");
      if (redirectTimer != null) {
        redirectTimer.schedule(1000 * sessionExpirationInterval);
      }
      double processUidlStart=Duration.currentTimeMillis();
      Set<ServerConnector> createdConnectors=createConnectorsIfNeeded(json);
      Collection<StateChangeEvent> pendingStateChangeEvents=updateConnectorState(json,createdConnectors);
      ConnectorHierarchyUpdateResult connectorHierarchyUpdateResult=updateConnectorHierarchy(json);
      sendHierarchyChangeEvents(connectorHierarchyUpdateResult.events);
      updateCaptions(pendingStateChangeEvents,connectorHierarchyUpdateResult.parentChanged);
      delegateToWidget(pendingStateChangeEvents);
      sendStateChangeEvents(pendingStateChangeEvents);
      updateVaadin6StyleConnectors(json);
      handleRpcInvocations(json);
      if (json.containsKey("dd")) {
        VDragAndDropManager.get().handleServerResponse(json.getValueMap("dd"));
      }
      unregisterRemovedConnectors();
      VConsole.log("handleUIDLMessage: " + (Duration.currentTimeMillis() - processUidlStart) + " ms");
      Profiler.enter("Layout processing");
      try {
        LayoutManager layoutManager=getLayoutManager();
        layoutManager.setEverythingNeedsMeasure();
        layoutManager.layoutNow();
      }
 catch (      final Throwable e) {
        VConsole.error(e);
      }
      Profiler.leave("Layout processing");
      if (ApplicationConfiguration.isDebugMode()) {
        Profiler.enter("Dumping state changes to the console");
        VConsole.log(" * Dumping state changes to the console");
        VConsole.dirUIDL(json,ApplicationConnection.this);
        Profiler.leave("Dumping state changes to the console");
      }
      if (meta != null) {
        Profiler.enter("Error handling");
        if (meta.containsKey("appError")) {
          ValueMap error=meta.getValueMap("appError");
          showError(null,error.getString("caption"),error.getString("message"),error.getString("url"));
          applicationRunning=false;
        }
        if (validatingLayouts) {
          Set<ComponentConnector> zeroHeightComponents=new HashSet<ComponentConnector>();
          Set<ComponentConnector> zeroWidthComponents=new HashSet<ComponentConnector>();
          findZeroSizeComponents(zeroHeightComponents,zeroWidthComponents,getUIConnector());
          VConsole.printLayoutProblems(meta,ApplicationConnection.this,zeroHeightComponents,zeroWidthComponents);
          validatingLayouts=false;
        }
        Profiler.leave("Error handling");
      }
      lastProcessingTime=(int)((new Date().getTime()) - start.getTime());
      totalProcessingTime+=lastProcessingTime;
      VConsole.log(" Processing time was " + String.valueOf(lastProcessingTime) + "ms for "+ jsonText.length()+ " characters of JSON");
      VConsole.log("Referenced paintables: " + connectorMap.size());
      endRequest();
      if (Profiler.isEnabled()) {
        Scheduler.get().scheduleDeferred(new ScheduledCommand(){
          @Override public void execute(){
            Profiler.logTimings();
            Profiler.reset();
          }
        }
);
      }
    }
    /** 
 * Properly clean up any old stuff to ensure everything is properly
 * reinitialized.
 */
    private void prepareRepaintAll(){
      String uiConnectorId=uIConnector.getConnectorId();
      if (uiConnectorId == null) {
        return;
      }
      JSONObject fakeHierarchy=new JSONObject();
      fakeHierarchy.put(uiConnectorId,new JSONArray());
      JSONObject fakeJson=new JSONObject();
      fakeJson.put("hierarchy",fakeHierarchy);
      ValueMap fakeValueMap=fakeJson.getJavaScriptObject().cast();
      ConnectorHierarchyUpdateResult connectorHierarchyUpdateResult=updateConnectorHierarchy(fakeValueMap);
      sendHierarchyChangeEvents(connectorHierarchyUpdateResult.events);
      unregisterRemovedConnectors();
      getLayoutManager().cleanMeasuredSizes();
    }
    private void updateCaptions(    Collection<StateChangeEvent> pendingStateChangeEvents,    Collection<ServerConnector> parentChanged){
      Profiler.enter("updateCaptions");
      HashSet<ServerConnector> needsCaptionUpdate=new HashSet<ServerConnector>(parentChanged);
      for (      StateChangeEvent event : pendingStateChangeEvents) {
        if (VCaption.mightChange(event)) {
          ServerConnector connector=event.getConnector();
          needsCaptionUpdate.add(connector);
        }
      }
      for (      ServerConnector child : needsCaptionUpdate) {
        if (child instanceof ComponentConnector && ((ComponentConnector)child).delegateCaptionHandling()) {
          ServerConnector parent=child.getParent();
          if (parent instanceof HasComponentsConnector) {
            Profiler.enter("HasComponentsConnector.updateCaption");
            ((HasComponentsConnector)parent).updateCaption((ComponentConnector)child);
            Profiler.leave("HasComponentsConnector.updateCaption");
          }
        }
      }
      Profiler.leave("updateCaptions");
    }
    private void delegateToWidget(    Collection<StateChangeEvent> pendingStateChangeEvents){
      Profiler.enter("@DelegateToWidget");
      VConsole.log(" * Running @DelegateToWidget");
      for (      StateChangeEvent sce : pendingStateChangeEvents) {
        ServerConnector connector=sce.getConnector();
        if (connector instanceof ComponentConnector) {
          ComponentConnector component=(ComponentConnector)connector;
          Type stateType=AbstractConnector.getStateType(component);
          FastStringSet changedProperties=sce.getChangedPropertiesFastSet();
          JsArrayString dump=changedProperties.dump();
          for (int i=0; i < dump.length(); i++) {
            String propertyName=dump.get(i);
            Property property=stateType.getProperty(propertyName);
            String method=property.getDelegateToWidgetMethodName();
            if (method != null) {
              Profiler.enter("doDelegateToWidget");
              doDelegateToWidget(component,property,method);
              Profiler.leave("doDelegateToWidget");
            }
          }
        }
      }
      Profiler.leave("@DelegateToWidget");
    }
    private void doDelegateToWidget(    ComponentConnector component,    Property property,    String methodName){
      Type type=TypeData.getType(component.getClass());
      try {
        Type widgetType=type.getMethod("getWidget").getReturnType();
        Widget widget=component.getWidget();
        Object propertyValue=property.getValue(component.getState());
        widgetType.getMethod(methodName).invoke(widget,propertyValue);
      }
 catch (      NoDataException e) {
        throw new RuntimeException("Missing data needed to invoke @DelegateToWidget for " + Util.getSimpleName(component),e);
      }
    }
    /** 
 * Sends the state change events created while updating the state
 * information.
 * This must be called after hierarchy change listeners have been
 * called. At least caption updates for the parent are strange if
 * fired from state change listeners and thus calls the parent
 * BEFORE the parent is aware of the child (through a
 * ConnectorHierarchyChangedEvent)
 * @param pendingStateChangeEventsThe events to send
 */
    private void sendStateChangeEvents(    Collection<StateChangeEvent> pendingStateChangeEvents){
      Profiler.enter("sendStateChangeEvents");
      VConsole.log(" * Sending state change events");
      for (      StateChangeEvent sce : pendingStateChangeEvents) {
        try {
          sce.getConnector().fireEvent(sce);
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      Profiler.leave("sendStateChangeEvents");
    }
    private void unregisterRemovedConnectors(){
      Profiler.enter("unregisterRemovedConnectors");
      int unregistered=0;
      JsArrayObject<ServerConnector> currentConnectors=connectorMap.getConnectorsAsJsArray();
      int size=currentConnectors.size();
      for (int i=0; i < size; i++) {
        ServerConnector c=currentConnectors.get(i);
        if (c.getParent() != null) {
          if (!c.getParent().getChildren().contains(c)) {
            VConsole.error("ERROR: Connector is connected to a parent but the parent does not contain the connector");
          }
        }
 else         if (c == getUIConnector()) {
        }
 else         if (c instanceof WindowConnector && getUIConnector().hasSubWindow((WindowConnector)c)) {
        }
 else {
          connectorMap.unregisterConnector(c);
          unregistered++;
        }
      }
      VConsole.log("* Unregistered " + unregistered + " connectors");
      Profiler.leave("unregisterRemovedConnectors");
    }
    private Set<ServerConnector> createConnectorsIfNeeded(    ValueMap json){
      VConsole.log(" * Creating connectors (if needed)");
      if (!json.containsKey("types")) {
        return Collections.emptySet();
      }
      Profiler.enter("Creating connectors");
      Set<ServerConnector> createdConnectors=new HashSet<ServerConnector>();
      ValueMap types=json.getValueMap("types");
      JsArrayString keyArray=types.getKeyArray();
      for (int i=0; i < keyArray.length(); i++) {
        try {
          String connectorId=keyArray.get(i);
          int connectorType=Integer.parseInt(types.getString((connectorId)));
          ServerConnector connector=connectorMap.getConnector(connectorId);
          if (connector != null) {
            continue;
          }
          Class<? extends ServerConnector> connectorClass=configuration.getConnectorClassByEncodedTag(connectorType);
          if (connectorClass != UIConnector.class) {
            Profiler.enter("ApplicationConnection.getConnector");
            connector=getConnector(connectorId,connectorType);
            Profiler.leave("ApplicationConnection.getConnector");
            createdConnectors.add(connector);
          }
 else {
            connectorMap.registerConnector(connectorId,uIConnector);
            uIConnector.doInit(connectorId,ApplicationConnection.this);
            createdConnectors.add(uIConnector);
          }
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      Profiler.leave("Creating connectors");
      return createdConnectors;
    }
    private void updateVaadin6StyleConnectors(    ValueMap json){
      Profiler.enter("updateVaadin6StyleConnectors");
      JsArray<ValueMap> changes=json.getJSValueMapArray("changes");
      int length=changes.length();
      VConsole.log(" * Passing UIDL to Vaadin 6 style connectors");
      for (int i=0; i < length; i++) {
        try {
          final UIDL change=changes.get(i).cast();
          final UIDL uidl=change.getChildUIDL(0);
          String connectorId=uidl.getId();
          final ComponentConnector legacyConnector=(ComponentConnector)connectorMap.getConnector(connectorId);
          if (legacyConnector instanceof Paintable) {
            String key=null;
            if (Profiler.isEnabled()) {
              key="updateFromUIDL for " + Util.getSimpleName(legacyConnector);
              Profiler.enter(key);
            }
            ((Paintable)legacyConnector).updateFromUIDL(uidl,ApplicationConnection.this);
            if (Profiler.isEnabled()) {
              Profiler.leave(key);
            }
          }
 else           if (legacyConnector == null) {
            VConsole.error("Received update for " + uidl.getTag() + ", but there is no such paintable ("+ connectorId+ ") rendered.");
          }
 else {
            VConsole.error("Server sent Vaadin 6 style updates for " + Util.getConnectorString(legacyConnector) + " but this is not a Vaadin 6 Paintable");
          }
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      Profiler.leave("updateVaadin6StyleConnectors");
    }
    private void sendHierarchyChangeEvents(    Collection<ConnectorHierarchyChangeEvent> pendingHierarchyChangeEvents){
      if (pendingHierarchyChangeEvents.isEmpty()) {
        return;
      }
      Profiler.enter("sendHierarchyChangeEvents");
      VConsole.log(" * Sending hierarchy change events");
      for (      ConnectorHierarchyChangeEvent event : pendingHierarchyChangeEvents) {
        try {
          logHierarchyChange(event);
          event.getConnector().fireEvent(event);
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      Profiler.leave("sendHierarchyChangeEvents");
    }
    private void logHierarchyChange(    ConnectorHierarchyChangeEvent event){
      if (true) {
        return;
      }
      VConsole.log("Hierarchy changed for " + Util.getConnectorString(event.getConnector()));
      String oldChildren="* Old children: ";
      for (      ComponentConnector child : event.getOldChildren()) {
        oldChildren+=Util.getConnectorString(child) + " ";
      }
      VConsole.log(oldChildren);
      String newChildren="* New children: ";
      HasComponentsConnector parent=(HasComponentsConnector)event.getConnector();
      for (      ComponentConnector child : parent.getChildComponents()) {
        newChildren+=Util.getConnectorString(child) + " ";
      }
      VConsole.log(newChildren);
    }
    private Collection<StateChangeEvent> updateConnectorState(    ValueMap json,    Set<ServerConnector> newConnectors){
      ArrayList<StateChangeEvent> events=new ArrayList<StateChangeEvent>();
      VConsole.log(" * Updating connector states");
      if (!json.containsKey("state")) {
        return events;
      }
      Profiler.enter("updateConnectorState");
      HashSet<ServerConnector> remainingNewConnectors=new HashSet<ServerConnector>(newConnectors);
      ValueMap states=json.getValueMap("state");
      JsArrayString keyArray=states.getKeyArray();
      for (int i=0; i < keyArray.length(); i++) {
        try {
          String connectorId=keyArray.get(i);
          ServerConnector connector=connectorMap.getConnector(connectorId);
          if (null != connector) {
            Profiler.enter("updateConnectorState inner loop");
            if (Profiler.isEnabled()) {
              Profiler.enter("Decode connector state " + Util.getSimpleName(connector));
            }
            JSONObject stateJson=new JSONObject(states.getJavaScriptObject(connectorId));
            if (connector instanceof HasJavaScriptConnectorHelper) {
              ((HasJavaScriptConnectorHelper)connector).getJavascriptConnectorHelper().setNativeState(stateJson.getJavaScriptObject());
            }
            SharedState state=connector.getState();
            Profiler.enter("updateConnectorState decodeValue");
            JsonDecoder.decodeValue(new Type(state.getClass().getName(),null),stateJson,state,ApplicationConnection.this);
            Profiler.leave("updateConnectorState decodeValue");
            if (Profiler.isEnabled()) {
              Profiler.leave("Decode connector state " + Util.getSimpleName(connector));
            }
            Profiler.enter("updateConnectorState create event");
            FastStringSet changedProperties=FastStringSet.create();
            addJsonFields(stateJson,changedProperties,"");
            if (newConnectors.contains(connector)) {
              remainingNewConnectors.remove(connector);
              FastStringSet allStateFields=getAllStateFields(AbstractConnector.getStateType(connector));
              changedProperties.addAll(allStateFields);
            }
            StateChangeEvent event=new StateChangeEvent(connector,changedProperties);
            events.add(event);
            Profiler.leave("updateConnectorState create event");
            Profiler.leave("updateConnectorState inner loop");
          }
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      Profiler.enter("updateConnectorState newWithoutState");
      for (      ServerConnector connector : remainingNewConnectors) {
        FastStringSet changedProperties=getAllStateFields(AbstractConnector.getStateType(connector));
        StateChangeEvent event=new StateChangeEvent(connector,changedProperties);
        events.add(event);
      }
      Profiler.leave("updateConnectorState newWithoutState");
      Profiler.leave("updateConnectorState");
      return events;
    }
    private FastStringSet getAllStateFields(    Type type){
      FastStringSet fields;
      fields=allStateFieldsCache.get(type.getBaseTypeName());
      if (fields == null) {
        Profiler.enter("getAllStateFields create");
        fields=FastStringSet.create();
        addAllStateFields(type,fields,"");
        allStateFieldsCache.put(type.getBaseTypeName(),fields);
        Profiler.leave("getAllStateFields create");
      }
      return fields;
    }
    /** 
 * Recursively adds the names of all properties in the provided
 * state type.
 * @param typethe type to process
 * @param foundPropertiesa set of all currently added properties
 * @param contextthe base name of the current object
 */
    private void addAllStateFields(    Type type,    FastStringSet foundProperties,    String context){
      try {
        JsArrayObject<Property> properties=type.getPropertiesAsArray();
        int size=properties.size();
        for (int i=0; i < size; i++) {
          Property property=properties.get(i);
          String propertyName=context + property.getName();
          foundProperties.add(propertyName);
          Type propertyType=property.getType();
          if (propertyType.hasProperties()) {
            addAllStateFields(propertyType,foundProperties,propertyName + ".");
          }
        }
      }
 catch (      NoDataException e) {
        throw new IllegalStateException("No property info for " + type + ". Did you remember to compile the right widgetset?",e);
      }
    }
    /** 
 * Recursively adds the names of all fields in all objects in the
 * provided json object.
 * @param jsonthe json object to process
 * @param fieldsa set of all currently added fields
 * @param contextthe base name of the current object
 */
    private void addJsonFields(    JSONObject json,    FastStringSet fields,    String context){
      for (      String key : json.keySet()) {
        String fieldName=context + key;
        fields.add(fieldName);
        JSONObject object=json.get(key).isObject();
        if (object != null) {
          addJsonFields(object,fields,fieldName + ".");
        }
      }
    }
    /** 
 * Updates the connector hierarchy and returns a list of events that
 * should be fired after update of the hierarchy and the state is
 * done.
 * @param jsonThe JSON containing the hierarchy information
 * @return A collection of events that should be fired when update
 * of hierarchy and state is complete and a list of all
 * connectors for which the parent has changed
 */
    private ConnectorHierarchyUpdateResult updateConnectorHierarchy(    ValueMap json){
      ConnectorHierarchyUpdateResult result=new ConnectorHierarchyUpdateResult();
      VConsole.log(" * Updating connector hierarchy");
      if (!json.containsKey("hierarchy")) {
        return result;
      }
      Profiler.enter("updateConnectorHierarchy");
      FastStringSet maybeDetached=FastStringSet.create();
      ValueMap hierarchies=json.getValueMap("hierarchy");
      JsArrayString hierarchyKeys=hierarchies.getKeyArray();
      for (int i=0; i < hierarchyKeys.length(); i++) {
        try {
          String connectorId=hierarchyKeys.get(i);
          ServerConnector parentConnector=connectorMap.getConnector(connectorId);
          JsArrayString childConnectorIds=hierarchies.getJSStringArray(connectorId);
          int childConnectorSize=childConnectorIds.length();
          List<ServerConnector> newChildren=new ArrayList<ServerConnector>();
          List<ComponentConnector> newComponents=new ArrayList<ComponentConnector>();
          for (int connectorIndex=0; connectorIndex < childConnectorSize; connectorIndex++) {
            String childConnectorId=childConnectorIds.get(connectorIndex);
            ServerConnector childConnector=connectorMap.getConnector(childConnectorId);
            if (childConnector == null) {
              VConsole.error("Hierarchy claims that " + childConnectorId + " is a child for "+ connectorId+ " ("+ parentConnector.getClass().getName()+ ") but no connector with id "+ childConnectorId+ " has been registered");
              continue;
            }
            newChildren.add(childConnector);
            if (childConnector instanceof ComponentConnector) {
              newComponents.add((ComponentConnector)childConnector);
            }
 else             if (!(childConnector instanceof AbstractExtensionConnector)) {
              throw new IllegalStateException(Util.getConnectorString(childConnector) + " is not a ComponentConnector nor an AbstractExtensionConnector");
            }
            if (childConnector.getParent() != parentConnector) {
              childConnector.setParent(parentConnector);
              result.parentChanged.add(childConnector);
              maybeDetached.remove(childConnectorId);
            }
          }
          List<ServerConnector> oldChildren=parentConnector.getChildren();
          boolean actuallyChanged=!Util.collectionsEquals(oldChildren,newChildren);
          if (!actuallyChanged) {
            continue;
          }
          if (parentConnector instanceof HasComponentsConnector) {
            HasComponentsConnector ccc=(HasComponentsConnector)parentConnector;
            List<ComponentConnector> oldComponents=ccc.getChildComponents();
            if (!Util.collectionsEquals(oldComponents,newComponents)) {
              ConnectorHierarchyChangeEvent event=GWT.create(ConnectorHierarchyChangeEvent.class);
              event.setOldChildren(oldComponents);
              event.setConnector(parentConnector);
              ccc.setChildComponents(newComponents);
              result.events.add(event);
            }
          }
 else           if (!newComponents.isEmpty()) {
            VConsole.error("Hierachy claims " + Util.getConnectorString(parentConnector) + " has component children even though it isn't a HasComponentsConnector");
          }
          parentConnector.setChildren(newChildren);
          for (          ServerConnector oldChild : oldChildren) {
            if (oldChild.getParent() != parentConnector) {
              continue;
            }
            if (!newChildren.contains(oldChild)) {
              maybeDetached.add(oldChild.getConnectorId());
            }
          }
        }
 catch (        final Throwable e) {
          VConsole.error(e);
        }
      }
      JsArrayString maybeDetachedArray=maybeDetached.dump();
      for (int i=0; i < maybeDetachedArray.length(); i++) {
        ServerConnector removed=connectorMap.getConnector(maybeDetachedArray.get(i));
        recursivelyDetach(removed,result.events);
      }
      Profiler.leave("updateConnectorHierarchy");
      return result;
    }
    private void recursivelyDetach(    ServerConnector connector,    List<ConnectorHierarchyChangeEvent> events){
      try {
        Type stateType=AbstractConnector.getStateType(connector);
        Object defaultState=stateType.createInstance();
        SharedState state=connector.getState();
        JsArrayObject<Property> properties=stateType.getPropertiesAsArray();
        int size=properties.size();
        for (int i=0; i < size; i++) {
          Property property=properties.get(i);
          property.setValue(state,property.getValue(defaultState));
        }
      }
 catch (      NoDataException e) {
        throw new RuntimeException("Can't reset state for " + Util.getConnectorString(connector),e);
      }
      for (      ServerConnector child : connector.getChildren()) {
        if (child.getParent() != connector) {
          continue;
        }
        recursivelyDetach(child,events);
      }
      connector.setChildren(Collections.<ServerConnector>emptyList());
      connector.setParent(null);
      if (connector instanceof HasComponentsConnector) {
        HasComponentsConnector ccc=(HasComponentsConnector)connector;
        List<ComponentConnector> oldChildren=ccc.getChildComponents();
        if (!oldChildren.isEmpty()) {
          ccc.setChildComponents(Collections.<ComponentConnector>emptyList());
          ConnectorHierarchyChangeEvent event=GWT.create(ConnectorHierarchyChangeEvent.class);
          event.setConnector(connector);
          event.setOldChildren(oldChildren);
          events.add(event);
        }
      }
    }
    private void handleRpcInvocations(    ValueMap json){
      if (json.containsKey("rpc")) {
        Profiler.enter("handleRpcInvocations");
        VConsole.log(" * Performing server to client RPC calls");
        JSONArray rpcCalls=new JSONArray(json.getJavaScriptObject("rpc"));
        int rpcLength=rpcCalls.size();
        for (int i=0; i < rpcLength; i++) {
          try {
            JSONArray rpcCall=(JSONArray)rpcCalls.get(i);
            rpcManager.parseAndApplyInvocation(rpcCall,ApplicationConnection.this);
          }
 catch (          final Throwable e) {
            VConsole.error(e);
          }
        }
        Profiler.leave("handleRpcInvocations");
      }
    }
  }
;
  ApplicationConfiguration.runWhenDependenciesLoaded(c);
}
