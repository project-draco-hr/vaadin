{
  ConnectorHierarchyUpdateResult result=new ConnectorHierarchyUpdateResult();
  getLogger().info(" * Updating connector hierarchy");
  if (!json.containsKey("hierarchy")) {
    return result;
  }
  Profiler.enter("updateConnectorHierarchy");
  FastStringSet maybeDetached=FastStringSet.create();
  ValueMap hierarchies=json.getValueMap("hierarchy");
  JsArrayString hierarchyKeys=hierarchies.getKeyArray();
  for (int i=0; i < hierarchyKeys.length(); i++) {
    try {
      Profiler.enter("updateConnectorHierarchy hierarchy entry");
      String connectorId=hierarchyKeys.get(i);
      ServerConnector parentConnector=connectorMap.getConnector(connectorId);
      JsArrayString childConnectorIds=hierarchies.getJSStringArray(connectorId);
      int childConnectorSize=childConnectorIds.length();
      Profiler.enter("updateConnectorHierarchy find new connectors");
      List<ServerConnector> newChildren=new ArrayList<ServerConnector>();
      List<ComponentConnector> newComponents=new ArrayList<ComponentConnector>();
      for (int connectorIndex=0; connectorIndex < childConnectorSize; connectorIndex++) {
        String childConnectorId=childConnectorIds.get(connectorIndex);
        ServerConnector childConnector=connectorMap.getConnector(childConnectorId);
        if (childConnector == null) {
          getLogger().severe("Hierarchy claims that " + childConnectorId + " is a child for "+ connectorId+ " ("+ parentConnector.getClass().getName()+ ") but no connector with id "+ childConnectorId+ " has been registered. "+ "More information might be available in the server-side log if assertions are enabled");
          continue;
        }
        newChildren.add(childConnector);
        if (childConnector instanceof ComponentConnector) {
          newComponents.add((ComponentConnector)childConnector);
        }
 else         if (!(childConnector instanceof AbstractExtensionConnector)) {
          throw new IllegalStateException(Util.getConnectorString(childConnector) + " is not a ComponentConnector nor an AbstractExtensionConnector");
        }
        if (childConnector.getParent() != parentConnector) {
          childConnector.setParent(parentConnector);
          result.parentChangedIds.add(childConnectorId);
          maybeDetached.remove(childConnectorId);
        }
      }
      Profiler.leave("updateConnectorHierarchy find new connectors");
      List<ServerConnector> oldChildren=parentConnector.getChildren();
      boolean actuallyChanged=!Util.collectionsEquals(oldChildren,newChildren);
      if (!actuallyChanged) {
        continue;
      }
      Profiler.enter("updateConnectorHierarchy handle HasComponentsConnector");
      if (parentConnector instanceof HasComponentsConnector) {
        HasComponentsConnector ccc=(HasComponentsConnector)parentConnector;
        List<ComponentConnector> oldComponents=ccc.getChildComponents();
        if (!Util.collectionsEquals(oldComponents,newComponents)) {
          ConnectorHierarchyChangeEvent event=GWT.create(ConnectorHierarchyChangeEvent.class);
          event.setOldChildren(oldComponents);
          event.setConnector(parentConnector);
          ccc.setChildComponents(newComponents);
          result.events.add(event);
        }
      }
 else       if (!newComponents.isEmpty()) {
        getLogger().severe("Hierachy claims " + Util.getConnectorString(parentConnector) + " has component children even though it isn't a HasComponentsConnector");
      }
      Profiler.leave("updateConnectorHierarchy handle HasComponentsConnector");
      Profiler.enter("updateConnectorHierarchy setChildren");
      parentConnector.setChildren(newChildren);
      Profiler.leave("updateConnectorHierarchy setChildren");
      Profiler.enter("updateConnectorHierarchy find removed children");
      for (      ServerConnector oldChild : oldChildren) {
        if (oldChild.getParent() != parentConnector) {
          continue;
        }
        if (!newChildren.contains(oldChild)) {
          maybeDetached.add(oldChild.getConnectorId());
        }
      }
      Profiler.leave("updateConnectorHierarchy find removed children");
    }
 catch (    final Throwable e) {
      getLogger().log(Level.SEVERE,"Error updating connector hierarchy",e);
    }
 finally {
      Profiler.leave("updateConnectorHierarchy hierarchy entry");
    }
  }
  Profiler.enter("updateConnectorHierarchy detach removed connectors");
  JsArrayString maybeDetachedArray=maybeDetached.dump();
  for (int i=0; i < maybeDetachedArray.length(); i++) {
    ServerConnector removed=connectorMap.getConnector(maybeDetachedArray.get(i));
    recursivelyDetach(removed,result.events,result.detachedConnectorIds);
  }
  Profiler.leave("updateConnectorHierarchy detach removed connectors");
  if (result.events.size() != 0) {
    onlyNoLayoutUpdates=false;
  }
  Profiler.leave("updateConnectorHierarchy");
  return result;
}
