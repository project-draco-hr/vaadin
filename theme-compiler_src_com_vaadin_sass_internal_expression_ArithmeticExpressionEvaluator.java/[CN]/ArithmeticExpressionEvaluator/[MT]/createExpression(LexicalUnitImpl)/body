{
  LexicalUnitImpl current=term;
  boolean afterOperand=false;
  Stack<Object> operands=new Stack<Object>();
  Stack<Object> operators=new Stack<Object>();
  inputTermLoop:   while (current != null) {
    if (afterOperand) {
      if (current.getLexicalUnitType() == SCSSLexicalUnit.SCSS_OPERATOR_RIGHT_PAREN) {
        Object operator=null;
        while (!operators.isEmpty() && ((operator=operators.pop()) != Parentheses.LEFT)) {
          createNewOperand((BinaryOperator)operator,operands);
        }
        current=current.getNextLexicalUnit();
        continue;
      }
      afterOperand=false;
      for (      BinaryOperator operator : BinaryOperator.values()) {
        if (current.getLexicalUnitType() == operator.type) {
          while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator)operators.peek()).precedence >= operator.precedence)) {
            createNewOperand((BinaryOperator)operators.pop(),operands);
          }
          operators.push(operator);
          current=current.getNextLexicalUnit();
          continue inputTermLoop;
        }
      }
      throw new ArithmeticException();
    }
    if (current.getLexicalUnitType() == SCSSLexicalUnit.SCSS_OPERATOR_LEFT_PAREN) {
      operators.push(Parentheses.LEFT);
      current=current.getNextLexicalUnit();
      continue;
    }
    afterOperand=true;
    operands.push(current);
    current=current.getNextLexicalUnit();
  }
  while (!operators.isEmpty()) {
    Object operator=operators.pop();
    if (operator == Parentheses.LEFT) {
      throw new ArithmeticException("Unexpected \"(\" found");
    }
    createNewOperand((BinaryOperator)operator,operands);
  }
  Object expression=operands.pop();
  if (!operands.isEmpty()) {
    LexicalUnitImpl operand=(LexicalUnitImpl)operands.peek();
    throw new ArithmeticException("Unexpected operand " + operand.toString() + " found");
  }
  return expression;
}
