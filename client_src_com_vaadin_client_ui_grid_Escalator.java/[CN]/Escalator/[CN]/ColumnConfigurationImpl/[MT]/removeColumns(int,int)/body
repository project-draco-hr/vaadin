{
  assertArgumentsAreValidAndWithinRange(index,numberOfColumns);
  flyweightRow.removeCells(index,numberOfColumns);
  if (index < frozenColumns) {
    if (index + numberOfColumns < frozenColumns) {
      frozenColumns-=numberOfColumns;
    }
 else {
      frozenColumns=index;
    }
  }
  List<Column> removedColumns=new ArrayList<Column>();
  for (int i=0; i < numberOfColumns; i++) {
    removedColumns.add(columns.remove(index));
  }
  if (hasSomethingInDom()) {
    for (    final AbstractRowContainer rowContainer : rowContainers) {
      rowContainer.paintRemoveColumns(index,numberOfColumns);
    }
    final int firstRemovedColumnLeft=columnConfiguration.getCalculatedColumnsWidth(Range.withLength(0,index));
    final boolean columnsWereRemovedFromLeftOfTheViewport=scroller.lastScrollLeft > firstRemovedColumnLeft;
    if (columnsWereRemovedFromLeftOfTheViewport) {
      int removedColumnsPxAmount=0;
      for (      ColumnConfigurationImpl.Column removedColumn : removedColumns) {
        removedColumnsPxAmount+=removedColumn.getCalculatedWidth();
      }
      final int leftByDiff=(int)(scroller.lastScrollLeft - removedColumnsPxAmount);
      final int newScrollLeft=Math.max(firstRemovedColumnLeft,leftByDiff);
      horizontalScrollbar.setScrollPos(newScrollLeft);
    }
    scroller.recalculateScrollbarsForVirtualViewport();
  }
}
