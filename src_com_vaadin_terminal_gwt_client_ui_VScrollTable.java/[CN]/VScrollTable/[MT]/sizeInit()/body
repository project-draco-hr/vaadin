{
  Iterator<Widget> headCells=tHead.iterator();
  int i=0;
  int totalExplicitColumnsWidths=0;
  int total=0;
  float expandRatioDivider=0;
  final int[] widths=new int[tHead.visibleCells.size()];
  tHead.enableBrowserIntelligence();
  while (headCells.hasNext()) {
    final HeaderCell hCell=(HeaderCell)headCells.next();
    int w=hCell.getWidth();
    if (hCell.isDefinedWidth()) {
      totalExplicitColumnsWidths+=w;
    }
 else {
      if (hCell.getExpandRatio() > 0) {
        expandRatioDivider+=hCell.getExpandRatio();
        w=0;
      }
 else {
        w=hCell.getNaturalColumnWidth(i);
      }
      hCell.setNaturalMinimumColumnWidth(w);
    }
    widths[i]=w;
    total+=w;
    i++;
  }
  tHead.disableBrowserIntelligence();
  boolean willHaveScrollbarz=willHaveScrollbars();
  if (width == null || "".equals(width)) {
    int w=total;
    w+=scrollBody.getCellExtraWidth() * visibleColOrder.length;
    if (willHaveScrollbarz) {
      w+=Util.getNativeScrollbarSize();
    }
    setContentWidth(w);
  }
  int availW=scrollBody.getAvailableWidth();
  if (BrowserInfo.get().isIE()) {
    availW=scrollBody.getAvailableWidth();
  }
  availW-=scrollBody.getCellExtraWidth() * visibleColOrder.length;
  if (willHaveScrollbarz) {
    availW-=Util.getNativeScrollbarSize();
  }
  boolean needsReLayout=false;
  if (availW > total) {
    final int extraSpace=availW - total;
    final int totalWidthR=total - totalExplicitColumnsWidths;
    needsReLayout=true;
    if (expandRatioDivider > 0) {
      headCells=tHead.iterator();
      i=0;
      while (headCells.hasNext()) {
        HeaderCell hCell=(HeaderCell)headCells.next();
        if (hCell.getExpandRatio() > 0) {
          int w=widths[i];
          final int newSpace=(int)(extraSpace * (hCell.getExpandRatio() / expandRatioDivider));
          w+=newSpace;
          widths[i]=w;
        }
        i++;
      }
    }
 else     if (totalWidthR > 0) {
      headCells=tHead.iterator();
      i=0;
      while (headCells.hasNext()) {
        HeaderCell hCell=(HeaderCell)headCells.next();
        if (!hCell.isDefinedWidth()) {
          int w=widths[i];
          final int newSpace=extraSpace * w / totalWidthR;
          w+=newSpace;
          widths[i]=w;
        }
        i++;
      }
    }
  }
 else {
  }
  i=0;
  headCells=tHead.iterator();
  while (headCells.hasNext()) {
    final HeaderCell hCell=(HeaderCell)headCells.next();
    if (isNewBody || hCell.getWidth() == -1) {
      final int w=widths[i];
      setColWidth(i,w,false);
    }
    i++;
  }
  if (needsReLayout) {
    scrollBody.reLayoutComponents();
  }
  updatePageLength();
  if (height == null || "".equals(height)) {
    if (pageLength == totalRows) {
      int bodyHeight=scrollBody.getRequiredHeight();
      bodyContainer.setHeight(bodyHeight + "px");
      Util.runWebkitOverflowAutoFix(bodyContainer.getElement());
    }
 else {
      int bodyHeight=(scrollBody.getRowHeight(true) * pageLength);
      bodyContainer.setHeight(bodyHeight + "px");
    }
  }
  isNewBody=false;
  if (firstvisible > 0) {
    DeferredCommand.addCommand(new Command(){
      public void execute(){
        bodyContainer.setScrollPosition(firstvisible * scrollBody.getRowHeight());
        firstRowInViewPort=firstvisible;
      }
    }
);
  }
  if (enabled) {
    if (scrollBody.getLastRendered() + 1 < firstRowInViewPort + pageLength + (int)cache_react_rate * pageLength) {
      if (totalRows - 1 > scrollBody.getLastRendered()) {
        int firstInNewSet=scrollBody.getLastRendered() + 1;
        rowRequestHandler.setReqFirstRow(firstInNewSet);
        int lastInNewSet=(int)(firstRowInViewPort + pageLength + cache_rate * pageLength);
        if (lastInNewSet > totalRows - 1) {
          lastInNewSet=totalRows - 1;
        }
        rowRequestHandler.setReqRows(lastInNewSet - firstInNewSet);
        rowRequestHandler.deferRowFetch(1);
      }
    }
  }
  initializedAndAttached=true;
}
