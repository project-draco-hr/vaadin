{
  if (TAG_THEME.equals(qName)) {
    this.name=atts.getValue(ATTR_NAME);
  }
 else   if (TAG_DESCRIPTION.equals(qName)) {
    this.description="(none)";
    this.openStrings.push(new StringBuffer());
  }
 else   if (TAG_EXTENDS.equals(qName)) {
    String themeName=atts.getValue(ATTR_THEME);
    if (this.name.equals(themeName))     throw new IllegalArgumentException("Theme " + this.name + " extends itself.");
    this.parentThemes.add(themeName);
  }
 else   if (TAG_FILE.equals(qName)) {
    File f=new File(atts.getValue(ATTR_NAME));
    if (this.openFilesets.isEmpty()) {
      throw new IllegalStateException("Element '" + TAG_FILE + "' must be within '"+ TAG_FILESET+ "' element.");
    }
    Fileset fs=(Fileset)this.openFilesets.peek();
    fs.addFile(f);
  }
 else   if (TAG_FILESET.equals(qName)) {
    Fileset fs;
    if (atts.getValue(ATTR_NAME) != null) {
      fs=new Fileset(atts.getValue(ATTR_NAME));
    }
 else {
      fs=new Fileset(atts.getValue(UNNAMED_FILESET));
    }
    if (this.files == null) {
      this.files=fs;
    }
    if (!this.openFilesets.isEmpty()) {
      ((Fileset)this.openFilesets.peek()).addFile(fs);
    }
    this.openFilesets.push(fs);
  }
 else   if (TAG_AUTHOR.equals(qName)) {
    this.author=new Author(atts.getValue(ATTR_NAME),atts.getValue(ATTR_EMAIL));
  }
 else   if (TAG_REQUIRE.equals(qName)) {
    if (this.openFilesets.isEmpty()) {
      throw new IllegalStateException("Element '" + TAG_REQUIRE + "' must be within '"+ TAG_FILESET+ "' element.");
    }
    Fileset fs=(Fileset)this.openFilesets.peek();
    this.openRequirements.push(fs.getRequirements());
  }
 else   if (TAG_SUPPORTS.equals(qName)) {
    if (this.openFilesets.isEmpty()) {
      throw new IllegalStateException("Element '" + TAG_REQUIRE + "' must be within '"+ TAG_FILESET+ "' element.");
    }
    if (this.openRequirements.isEmpty()) {
      throw new IllegalStateException("Element '" + TAG_SUPPORTS + "' must be within '"+ TAG_REQUIRE+ "' element.");
    }
    this.addRequirements(atts,(RequirementCollection)this.openRequirements.peek(),this.isNOTRequirementOpen);
  }
 else   if (TAG_NOT.equals(qName)) {
    this.isNOTRequirementOpen=true;
  }
 else   if (TAG_AND.equals(qName)) {
    this.openRequirements.push(new AndRequirement());
  }
 else   if (TAG_OR.equals(qName)) {
    this.openRequirements.push(new OrRequirement());
  }
}
