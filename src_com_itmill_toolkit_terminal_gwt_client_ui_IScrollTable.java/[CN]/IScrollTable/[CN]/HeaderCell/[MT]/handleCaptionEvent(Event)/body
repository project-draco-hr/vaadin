{
switch (DOM.eventGetType(event)) {
case Event.ONMOUSEDOWN:
    client.console.log("HeaderCaption: mouse down");
  if (columnReordering) {
    dragging=true;
    moved=false;
    colIndex=getColIndexByKey(cid);
    DOM.setCapture(getElement());
    this.headerX=tHead.getAbsoluteLeft();
    client.console.log("HeaderCaption: Caption set to capture mouse events");
    DOM.eventPreventDefault(event);
  }
break;
case Event.ONMOUSEUP:
client.console.log("HeaderCaption: mouseUP");
if (columnReordering) {
dragging=false;
DOM.releaseCapture(getElement());
client.console.log("HeaderCaption: Stopped column reordering");
if (moved) {
hideFloatingCopy();
tHead.removeSlotFocus();
if (closestSlot != colIndex && closestSlot != (colIndex + 1)) {
  if (closestSlot > colIndex)   reOrderColumn(cid,closestSlot - 1);
 else   reOrderColumn(cid,closestSlot);
}
}
}
if (!moved) {
if (sortable) {
if (sortColumn.equals(cid)) {
client.updateVariable(paintableId,"sortascending",!sortAscending,false);
}
 else {
client.updateVariable(paintableId,"sortcolumn",cid,false);
}
bodyContainer.setScrollPosition(0);
firstvisible=0;
rowRequestHandler.setReqFirstRow(0);
rowRequestHandler.setReqRows((int)(2 * pageLength * CACHE_RATE + pageLength));
rowRequestHandler.deferRowFetch();
}
break;
}
break;
case Event.ONMOUSEMOVE:
if (dragging) {
client.console.log("HeaderCaption: Dragging column, optimal index...");
if (!moved) {
createFloatingCopy();
moved=true;
}
int x=DOM.eventGetClientX(event);
int slotX=headerX;
closestSlot=colIndex;
int closestDistance=-1;
int start=0;
if (rowHeaders) {
start++;
}
int visibleCellCount=tHead.getVisibleCellCount();
for (int i=start; i <= visibleCellCount; i++) {
if (i > 0) {
String colKey=getColKeyByIndex(i - 1);
slotX+=getColWidth(colKey);
}
int dist=Math.abs(x - slotX);
if (closestDistance == -1 || dist < closestDistance) {
closestDistance=dist;
closestSlot=i;
}
}
tHead.focusSlot(closestSlot);
updateFloatingCopysPosition(x,-1);
client.console.log("" + closestSlot);
}
break;
default :
break;
}
}
