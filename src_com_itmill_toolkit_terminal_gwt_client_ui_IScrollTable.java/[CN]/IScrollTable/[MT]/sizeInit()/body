{
  Iterator<Widget> headCells=tHead.iterator();
  int i=0;
  int totalExplicitColumnsWidths=0;
  int total=0;
  float expandRatioDivider=0;
  final int[] widths=new int[tHead.visibleCells.size()];
  tHead.enableBrowserIntelligence();
  while (headCells.hasNext()) {
    final HeaderCell hCell=(HeaderCell)headCells.next();
    int w=hCell.getWidth();
    if (hCell.isDefinedWidth()) {
      totalExplicitColumnsWidths+=w;
    }
 else {
      if (hCell.getExpandRatio() > 0) {
        expandRatioDivider+=hCell.getExpandRatio();
        w=0;
      }
 else {
        w=hCell.getNaturalColumnWidth(i);
      }
      hCell.setNaturalMinimumColumnWidth(w);
    }
    widths[i]=w;
    total+=w;
    i++;
  }
  tHead.disableBrowserIntelligence();
  boolean willHaveScrollbarz=willHaveScrollbars();
  if (width == null || "".equals(width)) {
    int w=total;
    w+=tBody.getCellExtraWidth() * visibleColOrder.length;
    if (willHaveScrollbarz) {
      w+=Util.getNativeScrollbarSize();
    }
    setContentWidth(w);
  }
  int availW=tBody.getAvailableWidth();
  if (BrowserInfo.get().isIE()) {
    availW=tBody.getAvailableWidth();
  }
  availW-=tBody.getCellExtraWidth() * visibleColOrder.length;
  if (willHaveScrollbarz) {
    availW-=Util.getNativeScrollbarSize();
  }
  boolean needsReLayout=false;
  if (availW > total) {
    final int extraSpace=availW - total;
    final int totalWidthR=total - totalExplicitColumnsWidths;
    if (totalWidthR > 0) {
      needsReLayout=true;
      if (expandRatioDivider > 0) {
        headCells=tHead.iterator();
        i=0;
        while (headCells.hasNext()) {
          HeaderCell hCell=(HeaderCell)headCells.next();
          if (hCell.getExpandRatio() > 0) {
            int w=widths[i];
            final int newSpace=(int)(extraSpace * (hCell.getExpandRatio() / expandRatioDivider));
            w+=newSpace;
            widths[i]=w;
          }
          i++;
        }
      }
 else {
        headCells=tHead.iterator();
        i=0;
        while (headCells.hasNext()) {
          HeaderCell hCell=(HeaderCell)headCells.next();
          if (!hCell.isDefinedWidth()) {
            int w=widths[i];
            final int newSpace=extraSpace * w / totalWidthR;
            w+=newSpace;
            widths[i]=w;
          }
          i++;
        }
      }
    }
  }
 else {
  }
  i=0;
  headCells=tHead.iterator();
  while (headCells.hasNext()) {
    final HeaderCell hCell=(HeaderCell)headCells.next();
    if (isNewBody || hCell.getWidth() == -1) {
      final int w=widths[i];
      setColWidth(i,w,false);
    }
    i++;
  }
  if (needsReLayout) {
    tBody.reLayoutComponents();
  }
  if (height == null || "".equals(height)) {
    if (pageLength == totalRows) {
      int bodyHeight=tBody.getOffsetHeight();
      bodyContainer.setHeight(bodyHeight + "px");
      Util.runWebkitOverflowAutoFix(bodyContainer.getElement());
    }
 else {
      int bodyHeight=(tBody.getRowHeight(true) * pageLength);
      bodyContainer.setHeight(bodyHeight + "px");
    }
  }
  isNewBody=false;
  if (firstvisible > 0) {
    DeferredCommand.addCommand(new Command(){
      public void execute(){
        bodyContainer.setScrollPosition(firstvisible * tBody.getRowHeight());
        firstRowInViewPort=firstvisible;
      }
    }
);
  }
  if (enabled) {
    if (tBody.getLastRendered() + 1 < firstRowInViewPort + pageLength + CACHE_REACT_RATE * pageLength) {
      if (totalRows - 1 > tBody.getLastRendered()) {
        rowRequestHandler.setReqFirstRow(tBody.getLastRendered() + 1);
        rowRequestHandler.setReqRows((int)(pageLength * CACHE_RATE));
        rowRequestHandler.deferRowFetch(1);
      }
    }
  }
  initializedAndAttached=true;
}
