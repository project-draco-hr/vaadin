{
  getWidgetForPaintable().rendering=true;
  getWidgetForPaintable().client=client;
  if (client.updateComponent(this,uidl,true)) {
    getWidgetForPaintable().rendering=false;
    return;
  }
  clickEventHandler.handleEventHandlerRegistration(client);
  getWidgetForPaintable().canvas.setWidth("0px");
  getWidgetForPaintable().handleMargins(uidl);
  getWidgetForPaintable().detectSpacing(uidl);
  int cols=uidl.getIntAttribute("w");
  int rows=uidl.getIntAttribute("h");
  getWidgetForPaintable().columnWidths=new int[cols];
  getWidgetForPaintable().rowHeights=new int[rows];
  if (getWidgetForPaintable().cells == null) {
    getWidgetForPaintable().cells=new Cell[cols][rows];
  }
 else   if (getWidgetForPaintable().cells.length != cols || getWidgetForPaintable().cells[0].length != rows) {
    Cell[][] newCells=new Cell[cols][rows];
    for (int i=0; i < getWidgetForPaintable().cells.length; i++) {
      for (int j=0; j < getWidgetForPaintable().cells[i].length; j++) {
        if (i < cols && j < rows) {
          newCells[i][j]=getWidgetForPaintable().cells[i][j];
        }
      }
    }
    getWidgetForPaintable().cells=newCells;
  }
  getWidgetForPaintable().nonRenderedWidgets=(HashMap<Widget,ChildComponentContainer>)getWidgetForPaintable().widgetToComponentContainer.clone();
  final int[] alignments=uidl.getIntArrayAttribute("alignments");
  int alignmentIndex=0;
  LinkedList<Cell> pendingCells=new LinkedList<Cell>();
  LinkedList<Cell> relativeHeighted=new LinkedList<Cell>();
  for (final Iterator<?> i=uidl.getChildIterator(); i.hasNext(); ) {
    final UIDL r=(UIDL)i.next();
    if ("gr".equals(r.getTag())) {
      for (final Iterator<?> j=r.getChildIterator(); j.hasNext(); ) {
        final UIDL c=(UIDL)j.next();
        if ("gc".equals(c.getTag())) {
          Cell cell=getWidgetForPaintable().getCell(c);
          if (cell.hasContent()) {
            boolean rendered=cell.renderIfNoRelativeWidth();
            cell.alignment=alignments[alignmentIndex++];
            if (!rendered) {
              pendingCells.add(cell);
            }
            if (cell.colspan > 1) {
              getWidgetForPaintable().storeColSpannedCell(cell);
            }
 else             if (rendered) {
              if (getWidgetForPaintable().columnWidths[cell.col] < cell.getWidth()) {
                getWidgetForPaintable().columnWidths[cell.col]=cell.getWidth();
              }
            }
            if (cell.hasRelativeHeight()) {
              relativeHeighted.add(cell);
            }
          }
        }
      }
    }
  }
  getWidgetForPaintable().colExpandRatioArray=uidl.getIntArrayAttribute("colExpand");
  getWidgetForPaintable().rowExpandRatioArray=uidl.getIntArrayAttribute("rowExpand");
  getWidgetForPaintable().distributeColSpanWidths();
  getWidgetForPaintable().minColumnWidths=VGridLayout.cloneArray(getWidgetForPaintable().columnWidths);
  getWidgetForPaintable().expandColumns();
  getWidgetForPaintable().renderRemainingComponentsWithNoRelativeHeight(pendingCells);
  getWidgetForPaintable().detectRowHeights();
  getWidgetForPaintable().expandRows();
  getWidgetForPaintable().renderRemainingComponents(pendingCells);
  for (  Cell cell : relativeHeighted) {
    Widget widget2=cell.cc.getWidget();
    client.handleComponentRelativeSize(widget2);
    cell.cc.updateWidgetSize();
  }
  getWidgetForPaintable().layoutCells();
  for (  Widget w : getWidgetForPaintable().nonRenderedWidgets.keySet()) {
    ChildComponentContainer childComponentContainer=getWidgetForPaintable().widgetToComponentContainer.get(w);
    getWidgetForPaintable().widgetToCell.remove(w);
    getWidgetForPaintable().widgetToComponentContainer.remove(w);
    childComponentContainer.removeFromParent();
    VPaintableMap paintableMap=VPaintableMap.get(client);
    paintableMap.unregisterPaintable(paintableMap.getPaintable(w));
  }
  getWidgetForPaintable().nonRenderedWidgets=null;
  getWidgetForPaintable().rendering=false;
  getWidgetForPaintable().sizeChangedDuringRendering=false;
}
