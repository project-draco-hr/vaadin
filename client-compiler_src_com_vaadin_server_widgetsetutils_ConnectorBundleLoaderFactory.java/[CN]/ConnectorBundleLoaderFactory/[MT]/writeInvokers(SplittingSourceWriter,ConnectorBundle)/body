{
  Map<JClassType,Set<JMethod>> needsInvoker=bundle.getNeedsInvoker();
  for (  Entry<JClassType,Set<JMethod>> entry : needsInvoker.entrySet()) {
    JClassType type=entry.getKey();
    Set<JMethod> methods=entry.getValue();
    for (    JMethod method : methods) {
      w.print("store.setInvoker(");
      writeClassLiteral(w,type);
      w.print(", \"");
      w.print(escape(method.getName()));
      w.println("\", new Invoker() {");
      w.indent();
      w.println("public Object invoke(Object target, Object[] params) {");
      w.indent();
      JType returnType=method.getReturnType();
      boolean hasReturnType=!"void".equals(returnType.getQualifiedSourceName());
      if (hasReturnType) {
        w.print("return ");
      }
      JType[] parameterTypes=method.getParameterTypes();
      w.print("((" + type.getQualifiedSourceName() + ") target)."+ method.getName()+ "(");
      for (int i=0; i < parameterTypes.length; i++) {
        JType parameterType=parameterTypes[i];
        if (i != 0) {
          w.print(", ");
        }
        String parameterTypeName=getBoxedTypeName(parameterType);
        w.print("(" + parameterTypeName + ") params["+ i+ "]");
      }
      w.println(");");
      if (!hasReturnType) {
        w.println("return null;");
      }
      w.outdent();
      w.println("}");
      w.outdent();
      w.println("});");
      w.splitIfNeeded();
    }
  }
}
